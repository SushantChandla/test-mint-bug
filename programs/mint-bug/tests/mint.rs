#![cfg(feature = "test-bpf")]

use anchor_lang::prelude::{Pubkey, Rent};
use anchor_spl::associated_token::get_associated_token_address;
use solana_program_test::{processor, tokio, ProgramTest, ProgramTestContext};
use solana_sdk::{
    account::Account, instruction::Instruction, program_pack::Pack, signature::Keypair,
    signer::Signer, system_transaction, transaction::Transaction, transport,
};

#[tokio::test]
async fn mint_tokens() {
    let mut program_test = ProgramTest::new(
        "mint_bug",
        mint_bug::id(),
        // the entrypoint function is generated by the #[program] macro
        processor!(mint_bug::entry),
    );

    let investor = Keypair::new();
    let base_token_authority = Keypair::new();

    program_test.add_account(
        investor.pubkey(),
        Account {
            lamports: 100_000_000_000,
            ..Default::default()
        },
    );

    program_test.add_account(
        base_token_authority.pubkey(),
        Account {
            lamports: 10_000_000_000,
            ..Default::default()
        },
    );

    let mut context = program_test.start_with_context().await;

    let base_token_mint = Keypair::new();

    let latest_blockhash = context.last_blockhash;

    context
        .banks_client
        .process_transaction(system_transaction::create_account(
            &investor,
            &base_token_mint,
            latest_blockhash,
            Rent::default()
                .minimum_balance(anchor_spl::token::spl_token::state::Mint::get_packed_len()),
            anchor_spl::token::spl_token::state::Mint::get_packed_len() as u64,
            &anchor_spl::token::spl_token::id(),
        ))
        .await
        .unwrap();

    let initialize_base_token = anchor_spl::token::spl_token::instruction::initialize_mint(
        &anchor_spl::token::spl_token::id(),
        &base_token_mint.pubkey(),
        &base_token_authority.pubkey(),
        None,
        6,
    )
    .expect("failed to get instruction to create token");

    let initizalize_base_token_tx =
        get_signed_transaction(&context, &[initialize_base_token], &base_token_authority).await;

    context
        .banks_client
        .process_transaction(initizalize_base_token_tx)
        .await
        .expect("failed to intialize mint");

    let investor_associated_token_account = create_associated_token_account(
        &mut context,
        &investor.pubkey(),
        &base_token_mint.pubkey(),
        &investor,
    )
    .await
    .expect("failed to create associated token account");
}

pub async fn get_signed_transaction(
    program_context: &ProgramTestContext,
    instructions: &[Instruction],
    signer: &Keypair,
) -> Transaction {
    let mut initalize_tx = Transaction::new_with_payer(instructions, Some(&signer.pubkey()));
    let recent_blockhash = program_context.last_blockhash.clone();
    initalize_tx.partial_sign(&[signer], recent_blockhash);
    initalize_tx
}

async fn create_associated_token_account(
    context: &mut ProgramTestContext,
    account: &Pubkey,
    mint: &Pubkey,
    payer: &Keypair,
) -> transport::Result<Pubkey> {
    let associated_token_account = get_associated_token_address(account, mint);
    let associated_ix = spl_associated_token_account::instruction::create_associated_token_account(
        &payer.pubkey(),
        &account,
        &mint,
    );
    let associated_tx = get_signed_transaction(context, &[associated_ix], payer).await;

    context
        .banks_client
        .process_transaction(associated_tx)
        .await?;

    return Ok(associated_token_account);
}
